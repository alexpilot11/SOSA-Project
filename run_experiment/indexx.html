<!DOCTYPE html>
<html lang="en">
<head>
    <title>SOSA Preview Experiment</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
        body {
            font-family: Monospace;
            background-color: #f0f0f0;
            margin: 0px;
            overflow: hidden;
        }
    </style>
    <!--
    Basic layout from
    http://mrdoob.github.io/three.js/examples/canvas_geometry_board.html
    -->


</head>
<body>
<script src="js/three.js"></script>
<script src="js/Mirror.js"></script>
<script src="js/OrbitControls.js"></script>
<script src="js/Detector.js"></script>
<script src="js/DAT.GUI.js"></script>
<script src="js/Projector.js"></script>
<script src="js/CanvasRenderer.js"></script>
<script src="js/TrackballControls.js"></script>


<script>

    var container, board;
    var camera, controls, scene, renderer;
    var windowHalfX = window.innerWidth / 2;
    var windowHalfY = window.innerHeight / 2;

    var objects = [], plane;
    var raycaster = new THREE.Raycaster();
    var mouse = new THREE.Vector2(),
            offset = new THREE.Vector3(),
            INTERSECTED, SELECTED;

    init();
    animate();

    //Scene setup
    function init() {

        container = document.createElement( 'div' );
        document.body.appendChild( container );

        var info = document.createElement( 'div' );
        info.style.position = 'absolute';
        info.style.top = '10px';
        info.style.width = '100%';
        info.style.textAlign = 'center';
        info.style.color = '#ffffff';
        info.innerHTML = '<p>Preview Experiment</p>';
        container.appendChild( info );

        camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 1, 10000);
        camera.position.z = 700;
        camera.position.y = 700;
        controls = new THREE.TrackballControls(camera);
        controls.rotateSpeed = 0.0;
        controls.zoomSpeed = 1.2;
        controls.panSpeed = 0.8;
        controls.noZoom = true;
        controls.noPan = true;
        controls.staticMoving = true;
        controls.dynamicDampingFactor = 0.3;
        scene = new THREE.Scene();
        scene.add(new THREE.AmbientLight(0x505050));
        var light = new THREE.SpotLight(0xffffff, 1.5);
        light.position.set(0, 500, 2000);
        light.castShadow = true;
        light.shadowCameraNear = 200;
        light.shadowCameraFar = camera.far;
        light.shadowCameraFov = 50;
        light.shadowBias = -0.00022;
        light.shadowMapWidth = 2048;
        light.shadowMapHeight = 2048;
        scene.add(light);

        //Board
        var geometry = new THREE.BoxGeometry( 400, 20, 400 );
        for ( var i = 0; i < geometry.faces.length; i += 2 ) {
            var colo =  "rgb(255, 255, 255)";
            geometry.faces[ i ].color.set(new THREE.Color(colo));
            geometry.faces[ i + 1 ].color.set(new THREE.Color(colo));
        }
        var material = new THREE.MeshBasicMaterial( { vertexColors: THREE.FaceColors, overdraw: 0.5 } );
        board = new THREE.Mesh( geometry, material );
        board.position.y = 200;
        board.rotation.x = 1;
        scene.add( board );


        plane = new THREE.Mesh(
                new THREE.PlaneBufferGeometry(2000, 2000, 8, 8),
                new THREE.MeshBasicMaterial({visible: false})
        );
        scene.add(plane);

        //Renderer
        renderer = new THREE.WebGLRenderer({antialias: true});
        renderer.setClearColor( 0xf0f0f0 );
        renderer.setPixelRatio( window.devicePixelRatio );
        renderer.setSize( window.innerWidth, window.innerHeight );
        renderer.sortObjects = false;
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFShadowMap;
        container.appendChild( renderer.domElement );

        //Resize event listener
        window.addEventListener( 'resize', onWindowResize, false );

        //mouse event listeners
        renderer.domElement.addEventListener('mousemove', onDocumentMouseMove, false);
        renderer.domElement.addEventListener('mousedown', onDocumentMouseDown, false);
        renderer.domElement.addEventListener('mouseup', onDocumentMouseUp, false);



    }

    //MAKE THIS SCALE SHIT
    function onWindowResize() {
        windowHalfX = window.innerWidth / 2;
        windowHalfY = window.innerHeight / 2;

        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();

        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function onDocumentMouseMove(event) {
        event.preventDefault();
        mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
        mouse.y = -( event.clientY / window.innerHeight ) * 2 + 1;
        raycaster.setFromCamera(mouse, camera);
        if (SELECTED) {
            var intersects_board = raycaster.intersectObject(board);
            if (intersects_board.length > 0) {
                SELECTED.position.copy(intersects_board[0].point.sub(offset));
                SELECTED.position.x += 20;
                SELECTED.position.y += 20;
                SELECTED.position.z += 20;
                SELECTED.rotation = board.rotation;

            }



            return;
        }
        var intersects = raycaster.intersectObjects(objects);
        if (intersects.length > 0) {
            if (INTERSECTED != intersects[0].object) {
                if (INTERSECTED) INTERSECTED.material.color.setHex(INTERSECTED.currentHex);
                INTERSECTED = intersects[0].object;
                INTERSECTED.currentHex = INTERSECTED.material.color.getHex();
                plane.position.copy(INTERSECTED.position);
                plane.lookAt(camera.position);
            }
            container.style.cursor = 'pointer';
        } else {


            if (INTERSECTED) INTERSECTED.material.color.setHex(INTERSECTED.currentHex);
            INTERSECTED = null;
            container.style.cursor = 'auto';
        }

    }
    function onDocumentMouseDown(event) {
        event.preventDefault();
        raycaster.setFromCamera(mouse, camera);
        var intersects = raycaster.intersectObjects(objects);
        if (intersects.length > 0) {
            controls.enabled = false;
            SELECTED = intersects[0].object;
            var intersects = raycaster.intersectObject(plane);
            if (intersects.length > 0) {
                offset.copy(intersects[0].point).sub(plane.position);
            }
            container.style.cursor = 'move';
        }
    }
    function onDocumentMouseUp(event) {
        event.preventDefault();
        controls.enabled = true;
        if (INTERSECTED) {
            plane.position.copy(INTERSECTED.position);
            INTERSECTED.rotation.copy(board.rotation);

            SELECTED = null;
        }
        container.style.cursor = 'auto';
    }

    //
    function animate() {
        requestAnimationFrame( animate );
        render();
    }

    function render() {
        controls.update();

        renderer.render( scene, camera );
    }


    var finishExperiment = function() {
        console.log('Finished Experiment');
    };

    //Start GUI
    //GUI params
    var gui_controls = function() {
        this.rotationX = 1;
        this.boardR = 255;
        this.boardG = 255;
        this.boardB = 255;

        //sets the defaults
        this.setDefault = function(){
            boardTest.boardR = 255;
            boardTest.boardG = 255;
            boardTest.boardB = 255;
            board.material.color.setRGB(boardTest.boardR, boardTest.boardG, boardTest.boardB);
        };

        this.boardTiltDefaults = function() {
            boardTest.rotationX = 0;
            board.rotation.x =  1.15;
        };

        this.bgR = 255;
        this.bgG = 255;
        this.bgB = 255;
        this.backgroundDefaults = function() {
            boardTest.bgR = 255;
            boardTest.bgG = 255;
            boardTest.bgB = 255;
            renderer.setClearColor(0x000000);

        };
        this.hasBG = true;

        //MAKE THESE DO JSON THINGS
        this.import = function(){};
        this.export = function(){};

        //MAKE THESE DO LABEL THINGS
        this.showLabels = true;
        this.labelPosition = 60;
        this.labelShade = 100;
        this.labelSize = 75;

        this.labelDefaults = function(){
            boardTest.labelPosition = 60;
            boardTest.labelShade = 100;
            boardTest.labelSize = 75;

        };

        this.outputLoc = function(){};
        this.startExperiment = function() {
            document.getElementsByClassName('dg main a')[0].style.display = 'none';


            //create new gui with a Finish Experiment button
            var finish_gui = new dat.GUI();
            var finish = finish_gui.addFolder('Finish Experiment');
            finish.open();
            var finish_exp = { finishExperiment:function(){ finishExperiment(); }};
            finish_gui.add(finish_exp,'finishExperiment');

        };
    };



    //GUI creation
    //vars for rgb color strings
    var boardColor;
    var bgColor;

    /*
     *	listen() on the gui panels allows the gui to react to outside input i.e. setDefault etc
     *	onChange() updates the scene based off gui values
     *
     */
    var boardTest = new gui_controls();
    var gui = new dat.GUI();

    var appearance = gui.addFolder('Appearance');
    appearance.open();

    var boardAppearance = appearance.addFolder('Board1');
    boardAppearance.open();
    boardAppearance.add(boardTest, 'rotationX', -0.3, 1).listen().onChange( function(){

        board.rotation.x = (boardTest.rotationX);

//        for (var i = 0; i < objects.length; i++ ){
//
//            //TODO: ROTATE CUBE ABOUT BOARD HAVE TO TRANSLATE TO ORIGIN, ROTATE, THEN TRANSLATE BACK
//            //TODO: WHAT I HAVE HERE IS CONCEPTUALLY CORRECT, BUT INSTEAD OF SETTING THE POSITION BACK TO X, Y, AND Z,
//            //TODO: WE NEED TO TRANSLATE BY THE SAME AMOUNT IN A NEW VECTOR'S DIRECTION. PLAY WITH IT
//
//
//            var x = objects[i].position.x;
//            var y = objects[i].position.y;
//            var z = objects[i].position.z;
//
//            objects[i].position.x -= x;
//            objects[i].position.y -= y;
//            objects[i].position.z -= z;
//
//            objects[i].rotation.x = boardTest.rotationX;
//
//            objects[i].position.x += x;
//            objects[i].position.y += y;
//            objects[i].position.z += z;
//
////            var y = (objects[i].position.y * Math.cos(board.rotation.x) + objects[i].position.z * Math.sin(board.rotation.x));
////            var z = (objects[i].position.y * -Math.sin(board.rotation.x) + objects[i].position.z * Math.cos(board.rotation.x));
////            console.log(y + ", "+ z);
////            objects[i].position.y *= y;
////            objects[i].position.z *= z;
//
//        }
    });
    boardAppearance.add(boardTest, 'boardR', 0, 255).listen().onChange( function(){
        boardColor = "rgb("+Math.round(boardTest.boardR)+", "+Math.round(boardTest.boardG)+", "+Math.round(boardTest.boardB)+")";
        board.material.color.set(new THREE.Color(boardColor));
    });
    boardAppearance.add(boardTest, 'boardG', 0, 255).listen().onChange( function(){
        boardColor = "rgb("+Math.round(boardTest.boardR)+", "+Math.round(boardTest.boardG)+", "+Math.round(boardTest.boardB)+")";
        board.material.color.set(new THREE.Color(boardColor));
    });
    boardAppearance.add(boardTest, 'boardB', 0, 255).listen().onChange( function(){
        boardColor = "rgb("+Math.round(boardTest.boardR)+", "+Math.round(boardTest.boardG)+", "+Math.round(boardTest.boardB)+")";
        board.material.color.set(new THREE.Color(boardColor));
    });
    boardAppearance.add(boardTest, 'setDefault');
    boardAppearance.add(boardTest, 'boardTiltDefaults');

    var backgroundAppearance = appearance.addFolder('Background');
    backgroundAppearance.open();
    backgroundAppearance.add(boardTest, 'bgR', 0, 255).listen().onChange( function(){
        bgColor = "rgb("+Math.round(boardTest.bgR)+", "+Math.round(boardTest.bgG)+", "+Math.round(boardTest.bgB)+")";
        renderer.setClearColor(new THREE.Color(bgColor));
    });
    backgroundAppearance.add(boardTest, 'bgG', 0, 255).listen().onChange( function(){
        bgColor = "rgb("+Math.round(boardTest.bgR)+", "+Math.round(boardTest.bgG)+", "+Math.round(boardTest.bgB)+")";
        renderer.setClearColor(new THREE.Color(bgColor));
    });
    backgroundAppearance.add(boardTest, 'bgB', 0, 255).listen().onChange( function(){
        bgColor = "rgb("+Math.round(boardTest.bgR)+", "+Math.round(boardTest.bgG)+", "+Math.round(boardTest.bgB)+")";
        renderer.setClearColor(new THREE.Color(bgColor));
    });
    backgroundAppearance.add(boardTest, 'backgroundDefaults');

    var settingsIO = gui.addFolder('Import/Export Settings');
    settingsIO.open();
    settingsIO.add(boardTest, 'import');
    settingsIO.add(boardTest, 'export');

    var labels = gui.addFolder('Labels');
    labels.open();
    labels.add(boardTest, 'showLabels');
    labels.add(boardTest, 'labelPosition', 0, 100).listen();
    labels.add(boardTest, 'labelShade', 0, 100).listen();
    labels.add(boardTest, 'labelSize', 0, 100).listen();
    labels.add(boardTest, 'labelDefaults');


    var outputLocation = gui.addFolder('Log Output Location');
    outputLocation.open();
    outputLocation.add(boardTest, 'outputLoc');

    var startExperiment = gui.addFolder('Start Experiment');
    startExperiment.open();
    startExperiment.add(boardTest, 'startExperiment');



    //END GUI


    // Handle the listbox that will contain stimuli

    // For now this will be our sample JSON
    var importJSON = {
        orders: {
            order1: ['Stimulus1', 'Stimulus2', 'Stimulus3', 'Stimulus4', 'Stimulus5'],
            order2: ['Stimulus5', 'Stimulus4', 'Stimulus3', 'Stimulus2', 'Stimulus1'],
            order3: ['Stimulus2', 'Stimulus3', 'Stimulus1', 'Stimulus4', 'Stimulus5']
        },

        stimuli: {
            Stimulus1: {
                Name: 'StimDefault1',
                Image: 'img/test1.png',
                sizeX: '300px',
                sizeY: '300px'
            },
            Stimulus2: {
                Name: 'StimDefault2',
                Image: 'img/test2.png',
                sizeX: '300px',
                sizeY: '300px'
            },
            Stimulus3: {
                Name: 'StimDefault3',
                Image: 'img/test3.png',
                sizeX: '300px',
                sizeY: '300px'
            },
            Stimulus4: {
                Name: 'StimDefault4',
                Image: 'img/test4.jpg',
                sizeX: '300px',
                sizeY: '300px'
            },
            Stimulus5: {
                Name: 'StimDefault5',
                Image: 'img/test5.jpg',
                sizeX: '300px',
                sizeY: '300px'
            }
        }
    };

    // Read in the file instead of using this darn sample
    var readExperimentFromFile = function(fname) {

        // Variable initialization

        // Checks to ensure that the file is in the correct format
        console.log('just kidding ', fname);

        // Converts file to JSON
        console.log('currently already JSON heya');

        // Turns JSON to object
        var asObject;

        try {
            asObject = JSON.parse(fname);
        }

        catch (spookyScaryMonsterException) {
            asObject = fname;
        }
        return asObject;

    };

    // Create an object containing objects for each order.
    // Should not be named this
    var convertExperimentToThing = function(fname) {

        // Variable initialization
        var experiment = readExperimentFromFile(fname);
        var preppedStim = [];

        // Determine our order
        console.log('for now Im just assuming the first order');
        if (experiment.orders) {
            var order = experiment.orders.order1;
        }

        // Organize our stimuli based on our selected order
        for(var i=0; i<order.length; i++) {

            var key = order[i];

            if(key in experiment.stimuli) {
                preppedStim[i] = experiment.stimuli[key];
            }
        }

        return preppedStim;
    };

    var makeStims = function(stimuli) {
        for (var i = 0; i < stimuli.length; i++){

            // create box
            var geometry_box = new THREE.BoxGeometry(40, 40, 40);
            var object = new THREE.Mesh(geometry_box, new THREE.MeshBasicMaterial({map:THREE.ImageUtils.loadTexture(stimuli[i].Image)}));
            object.position.x = -500 + (i * 10);
            object.position.y = 100 + (i * 70);
            object.position.z = -i * 10;
            object.rotation.x = 20;
            object.rotation.z = -15;
            object.castShadow = true;
            object.receiveShadow = true;
            scene.add(object);
            objects.push(object);

        }

    };

    var preppedStim = convertExperimentToThing(importJSON);
    console.log(preppedStim);

    // createStimTable is a WIP. Currently breaks the GUI
//    createStimTable(preppedStim);
    makeStims(preppedStim);
</script>
</body>
</html>
