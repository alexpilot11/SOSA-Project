<!DOCTYPE html>
<html lang="en">
<head>
    <title>SOSA Preview Experiment</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
        body {
            font-family: Monospace;
            background-color: #000000;
            margin: 0px;
            overflow: hidden;
        }
    </style>
    <!--
    Basic layout from
    http://mrdoob.github.io/three.js/examples/canvas_geometry_board.html
    -->


</head>
<body>
<script src="js/three.js"></script>
<script src="js/Mirror.js"></script>
<script src="js/OrbitControls.js"></script>
<script src="js/Detector.js"></script>
<script src="js/DAT.GUI.js"></script>
<script src="js/Projector.js"></script>
<script src="js/CanvasRenderer.js"></script>
<script src="js/TrackballControls.js"></script>


<script>
    var container, board, stim_board;
    var camera, controls, scene, renderer;
    var windowHalfX = window.innerWidth / 2;
    var windowHalfY = window.innerHeight / 2;

    var objects = [], stim_labels = [], plane;
    var raycaster = new THREE.Raycaster();
    var mouse = new THREE.Vector2(),
            offset = new THREE.Vector3(),
            INTERSECTED, SELECTED;

    var outputLocationString;
    var canvas1 = [], context1 = [];
	
	var labelPos = 0;
	var labelColor = "rgba(255,0,0,.95)";
	var labelTexture;
	var canvaslabel = document.createElement('canvas');
	var contextlabel = canvaslabel.getContext('2d');
	var labelsChanged = false;
	
	//Sample JSON
	var importJSON = {
        orders: {
            order1: ['Stimulus1', 'Stimulus2', 'Stimulus3', 'Stimulus4', 'Stimulus5', 'Stimulus6', 'Stimulus7', 'Stimulus8', 'Stimulus9'],
            order2: ['Stimulus5', 'Stimulus4', 'Stimulus3', 'Stimulus2', 'Stimulus1'],
            order3: ['Stimulus2', 'Stimulus3', 'Stimulus1', 'Stimulus4', 'Stimulus5']
        },

        stimuli: {
            Stimulus1: {
                Name: 'StimDefault1',
                Image: 'img/test1.png',
                sizeX: '300px',
                sizeY: '300px'
            },
            Stimulus2: {
                Name: 'StimDefault2',
                Image: 'img/test2.png',
                sizeX: '300px',
                sizeY: '300px'
            },
            Stimulus3: {
                Name: 'StimDefault3',
                Image: 'img/test3.png',
                sizeX: '300px',
                sizeY: '300px'
            },
            Stimulus4: {
                Name: 'StimDefault4',
                Image: 'img/test4.jpg',
                sizeX: '300px',
                sizeY: '300px'
            },
            Stimulus5: {
                Name: 'StimDefault5',
                Image: 'img/test5.jpg',
                sizeX: '300px',
                sizeY: '300px'
            },
            Stimulus6: {
                Name: 'StimDefault5',
                Image: 'img/test5.jpg',
                sizeX: '300px',
                sizeY: '300px'
            },
            Stimulus7: {
                Name: 'StimDefault5',
                Image: 'img/test5.jpg',
                sizeX: '300px',
                sizeY: '300px'
            },
            Stimulus8: {
                Name: 'StimDefault5',
                Image: 'img/test5.jpg',
                sizeX: '300px',
                sizeY: '300px'
            },
            Stimulus9: {
                Name: 'StimDefault5',
                Image: 'img/test5.jpg',
                sizeX: '300px',
                sizeY: '300px'
            }

        }
    };
    init();
    animate();

    //Scene setup
    function init() {

        container = document.createElement('div');
        container.setAttribute('class', 'draggable');
        document.body.appendChild(container);

        var info = document.createElement('div');
        info.style.position = 'absolute';
        info.style.top = '10px';
        info.style.width = '100%';
        info.style.textAlign = 'center';
        info.style.color = '#FFFFFF';
        info.innerHTML = '<p>Preview Experiment</p>';
        container.appendChild(info);

        camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 1, 10000);
        camera.position.z = 700;
        camera.position.y = 700;
        controls = new THREE.TrackballControls(camera);
        controls.rotateSpeed = 0.0;
        controls.zoomSpeed = 1.2;
        controls.panSpeed = 0.8;
        controls.noZoom = false;
        controls.noPan = false;
        controls.staticMoving = true;
        controls.dynamicDampingFactor = 0.3;
        scene = new THREE.Scene();
        scene.add(new THREE.AmbientLight(0x505050));
        var light = new THREE.SpotLight(0xffffff, 1.5);
        light.position.set(0, 500, 2000);
        light.castShadow = true;
        light.shadowCameraNear = 200;
        light.shadowCameraFar = camera.far;
        light.shadowCameraFov = 50;
        light.shadowBias = -0.00022;
        light.shadowMapWidth = 2048;
        light.shadowMapHeight = 2048;
        scene.add(light);

        //Board
        var geometry = new THREE.BoxGeometry(windowHalfX * 1.5, 20, windowHalfY * 1.8);
        for (var i = 0; i < geometry.faces.length; i += 2) {
            var colo = "rgb(255, 255, 255)";
            geometry.faces[i].color.set(new THREE.Color(colo));
            geometry.faces[i + 1].color.set(new THREE.Color(colo));
        }
        var material = new THREE.MeshBasicMaterial({vertexColors: THREE.FaceColors, overdraw: 0.5});
        board = new THREE.Mesh(geometry, material);
        board.position.y = 0;
        board.rotation.x = 1;
        scene.add(board);
        board.visible = true;


        plane = new THREE.Mesh(
                new THREE.PlaneBufferGeometry(2000, 2000, 8, 8),
                new THREE.MeshBasicMaterial({visible: false})
        );
        scene.add(plane);

		var preppedStim = convertExperimentToThing(importJSON);
createGUI();
		makeStims(preppedStim);

		
        //Renderer
        renderer = new THREE.WebGLRenderer({antialias: true});
        renderer.setClearColor(0x000000);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.sortObjects = false;
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFShadowMap;
        container.appendChild(renderer.domElement);

        //Resize event listener
        window.addEventListener('resize', onWindowResize, false);

        //mouse event listeners
        renderer.domElement.addEventListener('mousemove', onDocumentMouseMove, false);
        renderer.domElement.addEventListener('mousedown', onDocumentMouseDown, false);
        renderer.domElement.addEventListener('mouseup', onDocumentMouseUp, false);
		
    }
    function onWindowResize() {
        windowHalfX = window.innerWidth / 2;
        windowHalfY = window.innerHeight / 2;

        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();

        renderer.setSize(window.innerWidth, window.innerHeight);
    }
    
	function onDocumentMouseMove(event) {
        event.preventDefault();
        mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
        mouse.y = -( event.clientY / window.innerHeight ) * 2 + 1;
        raycaster.setFromCamera(mouse, camera);
        if (SELECTED) {
            var intersects_board = raycaster.intersectObject(board);
            if (intersects_board.length > 0 && SELECTED.canMove) {
                SELECTED.onStimBoard = false;
                SELECTED.position.copy(intersects_board[0].point.sub(offset));
                SELECTED.position.x += 30;
                SELECTED.position.y += 30;
                SELECTED.position.z += 30;
                SELECTED.rotation.copy(board.rotation);
            }
            return;
        }
        var intersects = raycaster.intersectObjects(objects);
        if (intersects.length > 0) {
            if (INTERSECTED != intersects[0].object) {
                if (INTERSECTED) INTERSECTED.material.color.setHex(INTERSECTED.currentHex);
                INTERSECTED = intersects[0].object;
                INTERSECTED.currentHex = INTERSECTED.material.color.getHex();
                plane.position.copy(INTERSECTED.position);
                plane.lookAt(camera.position);
            }
            container.style.cursor = 'pointer';
        } else {
            if (INTERSECTED) INTERSECTED.material.color.setHex(INTERSECTED.currentHex);
            INTERSECTED = null;
            container.style.cursor = 'auto';
        }
    }
   
	function onDocumentMouseDown(event) {
        event.preventDefault();
        raycaster.setFromCamera(mouse, camera);
        var intersects = raycaster.intersectObjects(objects);
        if (intersects.length > 0) {
            controls.enabled = false;
            SELECTED = intersects[0].object;
            var intersects = raycaster.intersectObject(plane);
            if (intersects.length > 0) {
                offset.copy(intersects[0].point).sub(plane.position);
            }
            container.style.cursor = 'move';
        }
    }
    
	function onDocumentMouseUp(event) {
        event.preventDefault();
        controls.enabled = true;
        if (INTERSECTED) {
            plane.position.copy(INTERSECTED.position);
            SELECTED = null;
        }
        container.style.cursor = 'auto';
    }
    
	function animate() {
        requestAnimationFrame(animate);
        render();
    }
    
	function render() {
        controls.update();
        renderer.render(scene, camera);
        updateLabels();
		
    }

/*
	function updateLabels() {
        for (var i = 0; i < objects.length; i++) {
            var offsetY;
            if (objects[i].onStimBoard) {
                objects[i].label.position.set(objects[i].position.x - 100, objects[i].position.y, objects[i].position.z);
            }
            else {
                if (objects[i].position.y > 0) {
                    offsetY = 70;
                }
                else if (objects[i].position.y > -100) {
                    offsetY = 90;
                }
                else {
                    offsetY = 120;
                }
                objects[i].label.position.set(objects[i].position.x, objects[i].position.y + offsetY, objects[i].position.z);
            }
        }
    }
*/
	function updateLabels() {
        for (var i = 0; i < objects.length; i++) {
            var offsetY;
            if (objects[i].onStimBoard) {
                objects[i].label.position.set(objects[i].position.x - 100, objects[i].position.y, objects[i].position.z);
            }
            else {
                if (objects[i].position.y > 0) {
                    offsetY = 70;
                }
                else if (objects[i].position.y > -100) {
                    offsetY = 90;
                }
                else {
                    offsetY = 120;
                }
                objects[i].label.position.set(objects[i].position.x, objects[i].position.y + offsetY + labelPos, objects[i].position.z);
            }

        }
    }
    function createStimBoard() {
        //Stim Board
        var stim_geometry = new THREE.BoxGeometry(200, 20, 800);
        for (var i = 0; i < stim_geometry.faces.length; i += 2) {
            var stim_colo = "rgb(255, 255, 255)";
            stim_geometry.faces[i].color.set(new THREE.Color(stim_colo));
            stim_geometry.faces[i + 1].color.set(new THREE.Color(stim_colo));
        }
        var stim_material = new THREE.MeshBasicMaterial({vertexColors: THREE.FaceColors, overdraw: 0.5});
        stim_board = new THREE.Mesh(stim_geometry, stim_material);
        stim_board.position.y = 0;
        stim_board.position.x = -windowHalfX + 100;
        stim_board.position.z = board.position.z - 100;
        stim_board.rotation.x = 1;
        scene.add(stim_board);
        stim_board.visible = false;
        board.position.x += 200;
        board.position.y -= 100;
    }

    function createViewStimuli() {
        //create new gui with a Finish Experiment button
        var view_stims = new dat.GUI();
        var stims = view_stims.addFolder('View Stimuli');
        stims.open();
        var view = {
            viewStimuli: function () {
                viewStimuli();
            }
        };
        view_stims.add(view, 'viewStimuli');
        view_stims.domElement.style.position = 'absolute';
        view_stims.domElement.style.top = windowHalfY - 50 + 'px';
        view_stims.domElement.style.left = windowHalfX - 100 + 'px';
        view_stims.domElement.setAttribute('class', 'view_stims');

    }

    function viewStimuli() {
        document.getElementsByClassName('view_stims')[0].style.display = 'none';
        document.getElementsByClassName('draggable')[0].style.display = 'initial';

        createBeginExperiment();

    }

    function createBeginExperiment() {

        //create new gui with a Finish Experiment button
        var begin_gui = new dat.GUI();
        var begin = begin_gui.addFolder('Begin Experiment');
        begin.open();
        var begin_exp = {
            beginExperiment: function () {
                createFinishExperiment();
            }
        };
        begin_gui.add(begin_exp, 'beginExperiment');
        begin_gui.domElement.style.position = 'absolute';
        begin_gui.domElement.style.top = window.innerHeight - 50 + 'px';
        begin_gui.domElement.style.left = windowHalfX - 100 + 'px';
        begin_gui.domElement.setAttribute('class', 'begin_gui');
        board.visible = true;


    }
    
	function centerStimsOnBoard() {
        for (var i = 0; i < objects.length; i++) {
            objects[i].canMove = true;
            objects[i].onStimBoard = true;
            objects[i].position.x = stim_board.position.x - (i * 10) + 130;
            objects[i].position.y = stim_board.position.y + 350 - (i * 80);
//            objects[i].position.z = i * 30;
            objects[i].position.z = stim_board.position.z + (i * 50);

        }
    }

    function createFinishExperiment() {
        //create new gui with a Finish Experiment button
        document.getElementsByClassName('begin_gui')[0].style.display = 'none';
        createStimBoard();
        centerStimsOnBoard();
        var finish_gui = new dat.GUI();
        var finish = finish_gui.addFolder('Finish Experiment');
        finish.open();
        var finish_exp = {
            finishExperiment: function () {
                finishExperiment();
            }
        };
        finish_gui.add(finish_exp, 'finishExperiment');

    }

    var finishExperiment = function () {
        console.log('Finished Experiment');
    };
	
	function createGUI(){
		
		var labelsShowing = true;
		
		//Start GUI
		//GUI params
		var gui_controls = function () {
			this.rotationX = 1;
			this.boardR = 255;
			this.boardG = 255;
			this.boardB = 255;
	
			//sets the defaults
			this.setDefault = function () {
				boardTest.boardR = 255;
				boardTest.boardG = 255;
				boardTest.boardB = 255;
				board.material.color.setRGB(boardTest.boardR, boardTest.boardG, boardTest.boardB);
			};
	
			this.boardTiltDefaults = function () {
				boardTest.rotationX = 0;
				board.rotation.x = 1.15;
			};
	
			this.bgR = 255;
			this.bgG = 255;
			this.bgB = 255;
			this.backgroundDefaults = function () {
				boardTest.bgR = 255;
				boardTest.bgG = 255;
				boardTest.bgB = 255;
				renderer.setClearColor(0x000000);
	
			};
			this.hasBG = true;
	
			//MAKE THESE DO JSON THINGS
			this.import = function () {
			};
			this.export = function () {
			};
	
			//MAKE THESE DO LABEL THINGS
			this.showLabels = function () {
			if(labelsChanged != true){
		for(var i = 0; i < objects.length; i++){
			context1[i].restore();
			labelTexture = new THREE.Texture(canvas1[i]);
            labelTexture.needsUpdate = true;
			objects[i].label.material.map = labelTexture;
			wrapText(context1[i], "Stim #" + (i+1), 0, 50, 100, 20);
		}
		} else {
			labelColor = "rgba(" + Math.round(boardTest.labelR) + ", " + Math.round(boardTest.labelG) + ", " + Math.round(boardTest.labelB) + ", .95)";
				for (var i = 0; i < objects.length; i++) {
					overwriteLabel(i);
					context1[i].fillStyle = labelColor;
					labelTexture = new THREE.Texture(canvas1[i]);
					labelTexture.needsUpdate = true;
					objects[i].label.material.map = labelTexture;
					wrapText(context1[i], "Stim #" + (i+1), 0, 50, 100, 20);
				}
		}
			
			};
			this.hideLabels = function () {
					for(var i = 0; i < objects.length; i++){
			context1[i].save();
			context1[i].fillStyle = boardColor = "rgba(" + Math.round(boardTest.boardR) + ", " + Math.round(boardTest.boardG) + ", " + Math.round(boardTest.boardB) + ", .95)";
			context1[i].font = 'Bold 20px Arial';
			context1[i].clearRect(0, 0, 100, 50);			
			labelTexture = new THREE.Texture(canvas1[i]);
            labelTexture.needsUpdate = true;
			objects[i].label.material.map = labelTexture;
			wrapText(context1[i], "Stim #" + (i+1), 0, 50, 100, 20);		
		}
			};
			this.labelUp = function() {};
			this.labelDown = function() {};
			this.labelShade = 100;
			this.labelSize = 75;
			this.labelR = 255;
			this.labelG = 0;
			this.labelB = 0;
			this.labelDefaults = function () {

			};
	
			this.outputLoc = function () {
	
	//            var input = document.createElement('input');
	//            input.setAttribute('type', 'file');
	//            input.setAttribute('id', 'outputLoc');
	//            input.setAttribute('webkitdirectory', 'webkitdirectory');
	//            input.setAttribute('directory', 'directory');
	//            input.setAttribute('multiple', 'multiple');
	//            var evt = document.createEvent("MouseEvents");
	//            evt.initEvent("click", true, false);
	//            input.dispatchEvent(evt);
	//            console.log(input);
	
				outputLocationString = prompt('File in pc. click in bar. paste in this bar. profit.');
	
	
			};
	
			this.launchExperiment = function () {
				document.getElementsByClassName('dg main a')[0].style.display = 'none';
				document.getElementsByClassName('draggable')[0].style.display = 'none';
				board.visible = false;
				createViewStimuli();
	
			};
		};
		//GUI creation
		//vars for rgb color strings
		var boardColor;
		var bgColor;
	
		/*
		*	listen() on the gui panels allows the gui to react to outside input i.e. setDefault etc
		*	onChange() updates the scene based off gui values
		*
		*/
		var boardTest = new gui_controls();
		var gui = new dat.GUI();
	
		var appearance = gui.addFolder('Appearance');
		appearance.open();
		
		var boardAppearance = appearance.addFolder('Board1');
		boardAppearance.open();
		boardAppearance.add(boardTest, 'rotationX', -0.3, 1).listen().onChange(function () {
	
			board.rotation.x = (boardTest.rotationX);
	
	//        for (var i = 0; i < objects.length; i++ ){
	//
	//            //TODO: ROTATE CUBE ABOUT BOARD HAVE TO TRANSLATE TO ORIGIN, ROTATE, THEN TRANSLATE BACK
	//            //TODO: WHAT I HAVE HERE IS CONCEPTUALLY CORRECT, BUT INSTEAD OF SETTING THE POSITION BACK TO X, Y, AND Z,
	//            //TODO: WE NEED TO TRANSLATE BY THE SAME AMOUNT IN A NEW VECTOR'S DIRECTION. PLAY WITH IT
	//
	//
	//            var x = objects[i].position.x;
	//            var y = objects[i].position.y;
	//            var z = objects[i].position.z;
	//
	//            objects[i].position.x -= x;
	//            objects[i].position.y -= y;
	//            objects[i].position.z -= z;
	//
	//            objects[i].rotation.x = boardTest.rotationX;
	//
	//            objects[i].position.x += x;
	//            objects[i].position.y += y;
	//            objects[i].position.z += z;
	//
	////            var y = (objects[i].position.y * Math.cos(board.rotation.x) + objects[i].position.z * Math.sin(board.rotation.x));
	////            var z = (objects[i].position.y * -Math.sin(board.rotation.x) + objects[i].position.z * Math.cos(board.rotation.x));
	////            console.log(y + ", "+ z);
	////            objects[i].position.y *= y;
	////            objects[i].position.z *= z;
	//
	//        }
		});
		boardAppearance.add(boardTest, 'boardR', 0, 255).listen().onChange(function () {
			boardColor = "rgb(" + Math.round(boardTest.boardR) + ", " + Math.round(boardTest.boardG) + ", " + Math.round(boardTest.boardB) + ")";
			board.material.color.set(new THREE.Color(boardColor));
		});
		boardAppearance.add(boardTest, 'boardG', 0, 255).listen().onChange(function () {
			boardColor = "rgb(" + Math.round(boardTest.boardR) + ", " + Math.round(boardTest.boardG) + ", " + Math.round(boardTest.boardB) + ")";
			board.material.color.set(new THREE.Color(boardColor));
		});
		boardAppearance.add(boardTest, 'boardB', 0, 255).listen().onChange(function () {
			boardColor = "rgb(" + Math.round(boardTest.boardR) + ", " + Math.round(boardTest.boardG) + ", " + Math.round(boardTest.boardB) + ")";
			board.material.color.set(new THREE.Color(boardColor));
		});
		boardAppearance.add(boardTest, 'setDefault');
		boardAppearance.add(boardTest, 'boardTiltDefaults');
	
		var backgroundAppearance = appearance.addFolder('Background');
		backgroundAppearance.open();
		backgroundAppearance.add(boardTest, 'bgR', 0, 255).listen().onChange(function () {
			bgColor = "rgb(" + Math.round(boardTest.bgR) + ", " + Math.round(boardTest.bgG) + ", " + Math.round(boardTest.bgB) + ")";
			renderer.setClearColor(new THREE.Color(bgColor));
		});
		backgroundAppearance.add(boardTest, 'bgG', 0, 255).listen().onChange(function () {
			bgColor = "rgb(" + Math.round(boardTest.bgR) + ", " + Math.round(boardTest.bgG) + ", " + Math.round(boardTest.bgB) + ")";
			renderer.setClearColor(new THREE.Color(bgColor));
		});
		backgroundAppearance.add(boardTest, 'bgB', 0, 255).listen().onChange(function () {
			bgColor = "rgb(" + Math.round(boardTest.bgR) + ", " + Math.round(boardTest.bgG) + ", " + Math.round(boardTest.bgB) + ")";
			renderer.setClearColor(new THREE.Color(bgColor));
		});
		backgroundAppearance.add(boardTest, 'backgroundDefaults');
	
		var settingsIO = gui.addFolder('Import/Export Settings');
		settingsIO.open();
		settingsIO.add(boardTest, 'import');
		settingsIO.add(boardTest, 'export');
	
		var labels = gui.addFolder('Labels');
		labels.open();
		labels.add(boardTest, 'showLabels').listen().onChange(function(){
			if(labelsShowing != true){

			labelsShowing = true;
			}
		});
		labels.add(boardTest, 'hideLabels').listen().onChange(function(){
			if(labelsShowing != false){
			labelsShowing = false;
			}
		});
		labels.add(boardTest, 'labelUp').listen().onChange(function(){ 
		for (var i = 0; i < objects.length; i++) {
			labelPos += .5;
		}
		});
		labels.add(boardTest, 'labelDown').listen().onChange(function(){ 
			for (var i = 0; i < objects.length; i++) {
				labelPos -= .5;
			}
		});	
		labels.add(boardTest, 'labelR', 0, 255).listen().onChange(function () {
			if(labelsShowing == true){
			labelColor = "rgba(" + Math.round(boardTest.labelR) + ", " + Math.round(boardTest.labelG) + ", " + Math.round(boardTest.labelB) + ", .95)";
			for (var i = 0; i < objects.length; i++) {
				overwriteLabel(i);
				context1[i].fillStyle = labelColor;
				labelTexture = new THREE.Texture(canvas1[i]);
				labelTexture.needsUpdate = true;
				objects[i].label.material.map = labelTexture;
				wrapText(context1[i], "Stim #" + (i+1), 0, 50, 100, 20);
			}
			}
			labelsChanged = true;
		});
		labels.add(boardTest, 'labelG', 0, 255).listen().onChange(function () {
		if(labelsShowing == true){
			labelColor = "rgba(" + Math.round(boardTest.labelR) + ", " + Math.round(boardTest.labelG) + ", " + Math.round(boardTest.labelB) + ", .95)";
			for (var i = 0; i < objects.length; i++) {
				overwriteLabel(i);
				context1[i].fillStyle = labelColor;
				labelTexture = new THREE.Texture(canvas1[i]);
				labelTexture.needsUpdate = true;
				objects[i].label.material.map = labelTexture;
				wrapText(context1[i], "Stim #" + (i+1), 0, 50, 100, 20);
			}
			}
			labelsChanged = true;
		});
		labels.add(boardTest, 'labelB', 0, 255).listen().onChange(function () {
		if(labelsShowing == true){
			labelColor = "rgba(" + Math.round(boardTest.labelR) + ", " + Math.round(boardTest.labelG) + ", " + Math.round(boardTest.labelB) + ", .95)";
			for (var i = 0; i < objects.length; i++) {
				overwriteLabel(i);
				context1[i].fillStyle = labelColor;
				labelTexture = new THREE.Texture(canvas1[i]);
				labelTexture.needsUpdate = true;
				objects[i].label.material.map = labelTexture;
				wrapText(context1[i], "Stim #" + (i+1), 0, 50, 100, 20);
			}
			}
			labelsChanged = true;
		});
		labels.add(boardTest, 'labelShade', 0, 100).listen();
		labels.add(boardTest, 'labelSize', 0, 100).listen();
		labels.add(boardTest, 'labelDefaults');
	
		var outputLocation = gui.addFolder('Log Output Location');
		outputLocation.open();
		outputLocation.add(boardTest, 'outputLoc');
	
		var launchExperiment = gui.addFolder('Launch Experiment');
		launchExperiment.open();
		launchExperiment.add(boardTest, 'launchExperiment');
		//END GUI
	}
		
	
	// Handle the listbox that will contain stimuli
    // Read in the file instead of using this darn sample
	function readExperimentFromFile(fname) {

        // Variable initialization

        // Checks to ensure that the file is in the correct format
        console.log('just kidding ', fname);

        // Converts file to JSON
        console.log('currently already JSON heya');

        // Turns JSON to object
        var asObject;

        try {
            asObject = JSON.parse(fname);
        }

        catch (spookyScaryMonsterException) {
            asObject = fname;
        }
        return asObject;

    };

    // Create an object containing objects for each order.
    // Should not be named this
	function convertExperimentToThing(fname) {

        // Variable initialization
        var experiment = readExperimentFromFile(fname);
        var preppedStim = [];

        // Determine our order
        console.log('for now Im just assuming the first order');
        if (experiment.orders) {
            var order = experiment.orders.order1;
        }

        // Organize our stimuli based on our selected order
        for (var i = 0; i < order.length; i++) {

            var key = order[i];

            if (key in experiment.stimuli) {
                preppedStim[i] = experiment.stimuli[key];
            }
        }

        return preppedStim;
    };

	function makeStims(stimuli) {
        for (var i = 0; i < stimuli.length; i++) {

            // create box
            var geometry_box = new THREE.BoxGeometry(40, 40, 40);
            //This does images --- was not working for me on 4-10-16
			//var object = new THREE.Mesh(geometry_box, new THREE.MeshBasicMaterial({map: THREE.ImageUtils.loadTexture(stimuli[i].Image)}));
			var stimMat = new THREE.MeshBasicMaterial({color: 0x00ff00});
			var object = new THREE.Mesh(geometry_box, stimMat);
            var labelYoffset;

            object.castShadow = true;
            object.receiveShadow = true;
            objects.canMove = false;
            
            if (i >= 0 && i <= 2) {
                object.position.x = board.position.x + (i * 300) - 300;
                object.position.y = board.position.y + 200;
                object.position.z = board.position.z - 30;
                labelYoffset = 60;
            }

            else if (i >= 3 && i <= 5) {
                object.position.x = board.position.x + ((i - 4) * 300);
                object.position.y = board.position.y;
                object.position.z = board.position.z + 30;
                labelYoffset = 75;
            }
            else if (i >= 6 && i <= 8) {
                object.position.x = board.position.x + ((i - 7) * 300);
                object.position.y = board.position.y - 150;
                object.position.z = board.position.z + 110;
                labelYoffset = 20;
            }
            object.rotation = board.rotation;
            object.onStimBoard = false;
			scene.add(object);	
			makeLabel(stimuli, object, i);
        }

    }

	function makeLabel(stims, obj, count){
		//MAKE LABELS
        // create a canvas element
		var canvaslabel = document.createElement('canvas');
		var contextlabel = canvaslabel.getContext('2d');
		
            canvaslabel.width = 100;
            canvaslabel.height = 50;
            
            contextlabel.clearRect(0, 0, 100, 50);
            contextlabel.font = "Bold 20px Arial";
            contextlabel.fillStyle = labelColor;


            wrapText(contextlabel, "Stim #" + (count+1), 0, 50, 100, 20);
            context1.push(contextlabel);
            canvas1.push(canvaslabel);


            // canvas contents will be used for a texture
            var texture1 = new THREE.Texture(canvaslabel);
            texture1.needsUpdate = true;

            var material1 = new THREE.MeshBasicMaterial({map: texture1, side: THREE.DoubleSide});
            material1.transparent = true;

            var label = new THREE.Mesh(
                    new THREE.PlaneGeometry(canvaslabel.width, canvaslabel.height),
                    material1
            );
            label.position.set(obj.position.x - 130, obj.position.y + 10, obj.position.z);
            label.rotation.x = -.5;
            scene.add(label);
            obj.label = label;
			objects.push(obj);
	}

	function overwriteLabel(count){		
			context1[count].fillStyle = '#ffffff';
			context1[count].clearRect(0, 0, 100, 50);			
			labelTexture = new THREE.Texture(canvas1[count]);
            labelTexture.needsUpdate = true;
			objects[count].label.material.map = labelTexture;
			wrapText(context1[count], "Stim #" + (count+1), 0, 50, 100, 20);		
	}
/*	
	function hideLabels(){		
				for(var i = 0; i < objects.length; i++){
			context1[i].save();
			context1[i].fillStyle = '#ffffff';
			context1[i].fillRect(0, 0, 100, 50);			
			labelTexture = new THREE.Texture(canvas1[i]);
            labelTexture.needsUpdate = true;
			objects[i].label.material.map = labelTexture;
			wrapText(context1[i], "Stim #" + (i+1), 0, 50, 100, 20);		
		}
	}
	
	function showLabels(){
		if(labelsChanged != true){
		for(var i = 0; i < objects.length; i++){
			context1[i].restore();
			labelTexture = new THREE.Texture(canvas1[i]);
            labelTexture.needsUpdate = true;
			objects[i].label.material.map = labelTexture;
			wrapText(context1[i], "Stim #" + (i+1), 0, 50, 100, 20);
		}
		} else {
			labelColor = "rgba(" + Math.round(boardTest.labelR) + ", " + Math.round(boardTest.labelG) + ", " + Math.round(boardTest.labelB) + ", .95)";
				for (var i = 0; i < objects.length; i++) {
					overwriteLabel(i);
					context1[i].fillStyle = labelColor;
					labelTexture = new THREE.Texture(canvas1[i]);
					labelTexture.needsUpdate = true;
					objects[i].label.material.map = labelTexture;
					wrapText(context1[i], "Stim #" + (i+1), 0, 50, 100, 20);
				}
		}
	}
	
	*/
	
	
    
	
	function wrapText(context, text, x, y, maxWidth, lineHeight) {
        var words = text.split(' ');
        var line = '';

        for (var n = 0; n < words.length; n++) {
            var testLine = line + words[n] + ' ';
            var metrics = context.measureText(testLine);
            var testWidth = metrics.width;
            if (testWidth > maxWidth && n > 0) {
                context.fillText(line, x, y);
                line = words[n] + ' ';
                y += lineHeight;
            }
            else {
                line = testLine;
            }
        }
        context.fillText(line, x, y);
    }


</script>
</body>
</html>