<!DOCTYPE html>
<html lang="en">
<head>
    <title>SOSA Preview Experiment</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
        body {
            font-family: Monospace;
            background-color: #000000;
            margin: 0px;
            overflow: hidden;
        }
    </style>
    <!--
    Basic layout from
    http://mrdoob.github.io/three.js/examples/canvas_geometry_board.html
    -->


</head>
<body>
<script src="js/three.js"></script>
<script src="js/Mirror.js"></script>
<script src="js/OrbitControls.js"></script>
<script src="js/Detector.js"></script>
<script src="js/DAT.GUI.js"></script>
<script src="js/Projector.js"></script>
<script src="js/CanvasRenderer.js"></script>
<script src="js/TrackballControls.js"></script>


<script>

    var container, board;
    var camera, controls, scene, renderer;
    var windowHalfX = window.innerWidth / 2;
    var windowHalfY = window.innerHeight / 2;

    var objects = [], plane;
    var raycaster = new THREE.Raycaster();
    var mouse = new THREE.Vector2(),
            offset = new THREE.Vector3(),
            INTERSECTED, SELECTED;

    var outputLocation;

    init();
    animate();

    //Scene setup
    function init() {

        container = document.createElement('div');
        container.setAttribute('class', 'draggable');
        document.body.appendChild(container);

        var info = document.createElement('div');
        info.style.position = 'absolute';
        info.style.top = '10px';
        info.style.width = '100%';
        info.style.textAlign = 'center';
        info.style.color = '#FFFFFF';
        info.innerHTML = '<p>Preview Experiment</p>';
        container.appendChild(info);

        camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 1, 10000);
        camera.position.z = 700;
        camera.position.y = 700;
        controls = new THREE.TrackballControls(camera);
        controls.rotateSpeed = 0.0;
        controls.zoomSpeed = 1.2;
        controls.panSpeed = 0.8;
        controls.noZoom = true;
        controls.noPan = true;
        controls.staticMoving = true;
        controls.dynamicDampingFactor = 0.3;
        scene = new THREE.Scene();
        scene.add(new THREE.AmbientLight(0x505050));
        var light = new THREE.SpotLight(0xffffff, 1.5);
        light.position.set(0, 500, 2000);
        light.castShadow = true;
        light.shadowCameraNear = 200;
        light.shadowCameraFar = camera.far;
        light.shadowCameraFov = 50;
        light.shadowBias = -0.00022;
        light.shadowMapWidth = 2048;
        light.shadowMapHeight = 2048;
        scene.add(light);

        //Board
        var geometry = new THREE.BoxGeometry(400, 20, 400);
        for (var i = 0; i < geometry.faces.length; i += 2) {
            var colo = "rgb(255, 255, 255)";
            geometry.faces[i].color.set(new THREE.Color(colo));
            geometry.faces[i + 1].color.set(new THREE.Color(colo));
        }
        var material = new THREE.MeshBasicMaterial({vertexColors: THREE.FaceColors, overdraw: 0.5});
        board = new THREE.Mesh(geometry, material);
        board.position.y = 160;
        board.rotation.x = 1;
        scene.add(board);
        board.visible = true;


        plane = new THREE.Mesh(
                new THREE.PlaneBufferGeometry(2000, 2000, 8, 8),
                new THREE.MeshBasicMaterial({visible: false})
        );
        scene.add(plane);

        //Renderer
        renderer = new THREE.WebGLRenderer({antialias: true});
        renderer.setClearColor(0x000000);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.sortObjects = false;
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFShadowMap;
        container.appendChild(renderer.domElement);

        //Resize event listener
        window.addEventListener('resize', onWindowResize, false);

        //mouse event listeners
        renderer.domElement.addEventListener('mousemove', onDocumentMouseMove, false);
        renderer.domElement.addEventListener('mousedown', onDocumentMouseDown, false);
        renderer.domElement.addEventListener('mouseup', onDocumentMouseUp, false);


    }


    //MAKE THIS SCALE SHIT
    function onWindowResize() {
        windowHalfX = window.innerWidth / 2;
        windowHalfY = window.innerHeight / 2;

        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();

        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function onDocumentMouseMove(event) {
        event.preventDefault();
        mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
        mouse.y = -( event.clientY / window.innerHeight ) * 2 + 1;
        raycaster.setFromCamera(mouse, camera);
        if (SELECTED) {
            var intersects_board = raycaster.intersectObject(board);
            if (intersects_board.length > 0 && SELECTED.canMove) {
                SELECTED.position.copy(intersects_board[0].point.sub(offset));
                SELECTED.position.x += 30;
                SELECTED.position.y += 30;
                SELECTED.position.z += 30;
                SELECTED.rotation.copy(board.rotation);

            }


            return;
        }
        var intersects = raycaster.intersectObjects(objects);
        if (intersects.length > 0) {
            if (INTERSECTED != intersects[0].object) {
                if (INTERSECTED) INTERSECTED.material.color.setHex(INTERSECTED.currentHex);
                INTERSECTED = intersects[0].object;
                INTERSECTED.currentHex = INTERSECTED.material.color.getHex();
                plane.position.copy(INTERSECTED.position);
                plane.lookAt(camera.position);
            }
            container.style.cursor = 'pointer';
        } else {


            if (INTERSECTED) INTERSECTED.material.color.setHex(INTERSECTED.currentHex);
            INTERSECTED = null;
            container.style.cursor = 'auto';
        }

    }
    function onDocumentMouseDown(event) {
        event.preventDefault();
        raycaster.setFromCamera(mouse, camera);
        var intersects = raycaster.intersectObjects(objects);
        if (intersects.length > 0) {
            controls.enabled = false;
            SELECTED = intersects[0].object;
            var intersects = raycaster.intersectObject(plane);
            if (intersects.length > 0) {
                offset.copy(intersects[0].point).sub(plane.position);
            }
            container.style.cursor = 'move';
        }
    }
    function onDocumentMouseUp(event) {
        event.preventDefault();
        controls.enabled = true;
        if (INTERSECTED) {
            plane.position.copy(INTERSECTED.position);

            SELECTED = null;
        }
        container.style.cursor = 'auto';
    }

    //
    function animate() {
        requestAnimationFrame(animate);
        render();
    }

    function render() {
        controls.update();

        renderer.render(scene, camera);
    }


    //Start GUI
    //GUI params
    var gui_controls = function () {
        this.rotationX = 1;
        this.boardR = 255;
        this.boardG = 255;
        this.boardB = 255;

        //sets the defaults
        this.setDefault = function () {
            boardTest.boardR = 255;
            boardTest.boardG = 255;
            boardTest.boardB = 255;
            board.material.color.setRGB(boardTest.boardR, boardTest.boardG, boardTest.boardB);
        };

        this.boardTiltDefaults = function () {
            boardTest.rotationX = 0;
            board.rotation.x = 1.15;
        };

        this.bgR = 255;
        this.bgG = 255;
        this.bgB = 255;
        this.backgroundDefaults = function () {
            boardTest.bgR = 255;
            boardTest.bgG = 255;
            boardTest.bgB = 255;
            renderer.setClearColor(0x000000);

        };
        this.hasBG = true;

        //MAKE THESE DO JSON THINGS
        this.import = function () {
        };
        this.export = function () {
        };

        //MAKE THESE DO LABEL THINGS
        this.showLabels = function () {
        };
        this.labelPosition = 60;
        this.labelShade = 100;
        this.labelSize = 75;

        this.labelDefaults = function () {
            boardTest.labelPosition = 60;
            boardTest.labelShade = 100;
            boardTest.labelSize = 75;

        };

        this.outputLoc = function () {

//            var input = document.createElement('input');
//            input.setAttribute('type', 'file');
//            input.setAttribute('id', 'outputLoc');
//            input.setAttribute('webkitdirectory', 'webkitdirectory');
//            input.setAttribute('directory', 'directory');
//            input.setAttribute('multiple', 'multiple');
//            var evt = document.createEvent("MouseEvents");
//            evt.initEvent("click", true, false);
//            input.dispatchEvent(evt);
//            console.log(input);

            outputLocation = prompt('File in pc. click in bar. paste in this bar. profit.');


        };

        this.launchExperiment = function () {
            document.getElementsByClassName('dg main a')[0].style.display = 'none';
            document.getElementsByClassName('draggable')[0].style.display = 'none';
            board.visible = false;
            createViewStimuli();

        };
    };


    function createViewStimuli() {
        //create new gui with a Finish Experiment button
        var view_stims = new dat.GUI();
        var stims = view_stims.addFolder('View Stimuli');
        stims.open();
        var view = {
            viewStimuli: function () {
                viewStimuli();
            }
        };
        view_stims.add(view, 'viewStimuli');
        view_stims.domElement.style.position = 'absolute';
        view_stims.domElement.style.top = windowHalfY - 50 + 'px';
        view_stims.domElement.style.left = windowHalfX - 100 + 'px';
        view_stims.domElement.setAttribute('class', 'view_stims');

    }

    function viewStimuli() {
        document.getElementsByClassName('view_stims')[0].style.display = 'none';
        document.getElementsByClassName('draggable')[0].style.display = 'initial';

        createBeginExperiment();

    }

    function createBeginExperiment() {

        //create new gui with a Finish Experiment button
        var begin_gui = new dat.GUI();
        var begin = begin_gui.addFolder('Begin Experiment');
        begin.open();
        var begin_exp = {
            beginExperiment: function () {
                createFinishExperiment();
            }
        };
        begin_gui.add(begin_exp, 'beginExperiment');
        begin_gui.domElement.style.position = 'absolute';
        begin_gui.domElement.style.top = window.innerHeight - 50 + 'px';
        begin_gui.domElement.style.left = windowHalfX - 100 + 'px';
        begin_gui.domElement.setAttribute('class', 'begin_gui');
        board.visible = true;


    }

    function createFinishExperiment() {
        //create new gui with a Finish Experiment button
        document.getElementsByClassName('begin_gui')[0].style.display = 'none';
        for (var i = 0; i < objects.length; i++) {
            objects[i].canMove = true;
            objects[i].position.x = -500 - (i * 30);
            objects[i].position.y = 400 - (i * 100);
            objects[i].position.z = i * 20;

        }
        var finish_gui = new dat.GUI();
        var finish = finish_gui.addFolder('Finish Experiment');
        finish.open();
        var finish_exp = {
            finishExperiment: function () {
                finishExperiment();
            }
        };
        finish_gui.add(finish_exp, 'finishExperiment');

    }

    var finishExperiment = function () {
        console.log('Finished Experiment');
    };

    //GUI creation
    //vars for rgb color strings
    var boardColor;
    var bgColor;

    /*
     *	listen() on the gui panels allows the gui to react to outside input i.e. setDefault etc
     *	onChange() updates the scene based off gui values
     *
     */
    var boardTest = new gui_controls();
    var gui = new dat.GUI();

    var appearance = gui.addFolder('Appearance');
    appearance.open();

    var boardAppearance = appearance.addFolder('Board1');
    boardAppearance.open();
    boardAppearance.add(boardTest, 'rotationX', -0.3, 1).listen().onChange(function () {

        board.rotation.x = (boardTest.rotationX);

//        for (var i = 0; i < objects.length; i++ ){
//
//            //TODO: ROTATE CUBE ABOUT BOARD HAVE TO TRANSLATE TO ORIGIN, ROTATE, THEN TRANSLATE BACK
//            //TODO: WHAT I HAVE HERE IS CONCEPTUALLY CORRECT, BUT INSTEAD OF SETTING THE POSITION BACK TO X, Y, AND Z,
//            //TODO: WE NEED TO TRANSLATE BY THE SAME AMOUNT IN A NEW VECTOR'S DIRECTION. PLAY WITH IT
//
//
//            var x = objects[i].position.x;
//            var y = objects[i].position.y;
//            var z = objects[i].position.z;
//
//            objects[i].position.x -= x;
//            objects[i].position.y -= y;
//            objects[i].position.z -= z;
//
//            objects[i].rotation.x = boardTest.rotationX;
//
//            objects[i].position.x += x;
//            objects[i].position.y += y;
//            objects[i].position.z += z;
//
////            var y = (objects[i].position.y * Math.cos(board.rotation.x) + objects[i].position.z * Math.sin(board.rotation.x));
////            var z = (objects[i].position.y * -Math.sin(board.rotation.x) + objects[i].position.z * Math.cos(board.rotation.x));
////            console.log(y + ", "+ z);
////            objects[i].position.y *= y;
////            objects[i].position.z *= z;
//
//        }
    });
    boardAppearance.add(boardTest, 'boardR', 0, 255).listen().onChange(function () {
        boardColor = "rgb(" + Math.round(boardTest.boardR) + ", " + Math.round(boardTest.boardG) + ", " + Math.round(boardTest.boardB) + ")";
        board.material.color.set(new THREE.Color(boardColor));
    });
    boardAppearance.add(boardTest, 'boardG', 0, 255).listen().onChange(function () {
        boardColor = "rgb(" + Math.round(boardTest.boardR) + ", " + Math.round(boardTest.boardG) + ", " + Math.round(boardTest.boardB) + ")";
        board.material.color.set(new THREE.Color(boardColor));
    });
    boardAppearance.add(boardTest, 'boardB', 0, 255).listen().onChange(function () {
        boardColor = "rgb(" + Math.round(boardTest.boardR) + ", " + Math.round(boardTest.boardG) + ", " + Math.round(boardTest.boardB) + ")";
        board.material.color.set(new THREE.Color(boardColor));
    });
    boardAppearance.add(boardTest, 'setDefault');
    boardAppearance.add(boardTest, 'boardTiltDefaults');

    var backgroundAppearance = appearance.addFolder('Background');
    backgroundAppearance.open();
    backgroundAppearance.add(boardTest, 'bgR', 0, 255).listen().onChange(function () {
        bgColor = "rgb(" + Math.round(boardTest.bgR) + ", " + Math.round(boardTest.bgG) + ", " + Math.round(boardTest.bgB) + ")";
        renderer.setClearColor(new THREE.Color(bgColor));
    });
    backgroundAppearance.add(boardTest, 'bgG', 0, 255).listen().onChange(function () {
        bgColor = "rgb(" + Math.round(boardTest.bgR) + ", " + Math.round(boardTest.bgG) + ", " + Math.round(boardTest.bgB) + ")";
        renderer.setClearColor(new THREE.Color(bgColor));
    });
    backgroundAppearance.add(boardTest, 'bgB', 0, 255).listen().onChange(function () {
        bgColor = "rgb(" + Math.round(boardTest.bgR) + ", " + Math.round(boardTest.bgG) + ", " + Math.round(boardTest.bgB) + ")";
        renderer.setClearColor(new THREE.Color(bgColor));
    });
    backgroundAppearance.add(boardTest, 'backgroundDefaults');

    var settingsIO = gui.addFolder('Import/Export Settings');
    settingsIO.open();
    settingsIO.add(boardTest, 'import');
    settingsIO.add(boardTest, 'export');

    var labels = gui.addFolder('Labels');
    labels.open();
    labels.add(boardTest, 'showLabels');
    labels.add(boardTest, 'labelPosition', 0, 100).listen();
    labels.add(boardTest, 'labelShade', 0, 100).listen();
    labels.add(boardTest, 'labelSize', 0, 100).listen();
    labels.add(boardTest, 'labelDefaults');


    var outputLocation = gui.addFolder('Log Output Location');
    outputLocation.open();
    outputLocation.add(boardTest, 'outputLoc');

    var launchExperiment = gui.addFolder('Launch Experiment');
    launchExperiment.open();
    launchExperiment.add(boardTest, 'launchExperiment');


    //END GUI


    // Handle the listbox that will contain stimuli

    // For now this will be our sample JSON
    var importJSON = {
        orders: {
            order1: ['Stimulus1', 'Stimulus2', 'Stimulus3', 'Stimulus4', 'Stimulus5', 'Stimulus6', 'Stimulus7', 'Stimulus8', 'Stimulus9'],
            order2: ['Stimulus5', 'Stimulus4', 'Stimulus3', 'Stimulus2', 'Stimulus1'],
            order3: ['Stimulus2', 'Stimulus3', 'Stimulus1', 'Stimulus4', 'Stimulus5']
        },

        stimuli: {
            Stimulus1: {
                Name: 'StimDefault1',
                Image: 'img/test1.png',
                sizeX: '300px',
                sizeY: '300px'
            },
            Stimulus2: {
                Name: 'StimDefault2',
                Image: 'img/test2.png',
                sizeX: '300px',
                sizeY: '300px'
            },
            Stimulus3: {
                Name: 'StimDefault3',
                Image: 'img/test3.png',
                sizeX: '300px',
                sizeY: '300px'
            },
            Stimulus4: {
                Name: 'StimDefault4',
                Image: 'img/test4.jpg',
                sizeX: '300px',
                sizeY: '300px'
            },
            Stimulus5: {
                Name: 'StimDefault5',
                Image: 'img/test5.jpg',
                sizeX: '300px',
                sizeY: '300px'
            },
            Stimulus6: {
                Name: 'StimDefault5',
                Image: 'img/test5.jpg',
                sizeX: '300px',
                sizeY: '300px'
            },
            Stimulus7: {
                Name: 'StimDefault5',
                Image: 'img/test5.jpg',
                sizeX: '300px',
                sizeY: '300px'
            },
            Stimulus8: {
                Name: 'StimDefault5',
                Image: 'img/test5.jpg',
                sizeX: '300px',
                sizeY: '300px'
            },
            Stimulus9: {
                Name: 'StimDefault5',
                Image: 'img/test5.jpg',
                sizeX: '300px',
                sizeY: '300px'
            }

        }
    };

    // Read in the file instead of using this darn sample
    var readExperimentFromFile = function (fname) {

        // Variable initialization

        // Checks to ensure that the file is in the correct format
        console.log('just kidding ', fname);

        // Converts file to JSON
        console.log('currently already JSON heya');

        // Turns JSON to object
        var asObject;

        try {
            asObject = JSON.parse(fname);
        }

        catch (spookyScaryMonsterException) {
            asObject = fname;
        }
        return asObject;

    };

    // Create an object containing objects for each order.
    // Should not be named this
    var convertExperimentToThing = function (fname) {

        // Variable initialization
        var experiment = readExperimentFromFile(fname);
        var preppedStim = [];

        // Determine our order
        console.log('for now Im just assuming the first order');
        if (experiment.orders) {
            var order = experiment.orders.order1;
        }

        // Organize our stimuli based on our selected order
        for (var i = 0; i < order.length; i++) {

            var key = order[i];

            if (key in experiment.stimuli) {
                preppedStim[i] = experiment.stimuli[key];
            }
        }

        return preppedStim;
    };

    var makeStims = function (stimuli) {
        for (var i = 0; i < stimuli.length; i++) {

            // create box
            var geometry_box = new THREE.BoxGeometry(40, 40, 40);
            var object = new THREE.Mesh(geometry_box, new THREE.MeshBasicMaterial({map: THREE.ImageUtils.loadTexture(stimuli[i].Image)}));

            object.castShadow = true;
            object.receiveShadow = true;
            objects.canMove = false;
            scene.add(object);
            objects.push(object);


            if (i >= 0 && i <= 2) {



                object.position.x = board.position.x + (i * 90) - 100;
                object.position.y = board.position.y + 150;
                object.position.z = board.position.z - 30;
            }

            else if (i >= 3 && i <= 5) {
                object.position.x = board.position.x - 200 + (i * 90) - 180;
                object.position.y = board.position.y;
                object.position.z = board.position.z + 30;
            }
            else if (i >= 6 && i <= 8) {
                object.position.x = board.position.x - 200 + ((i-3) * 90) - 180;
                object.position.y = board.position.y - 100;
                object.position.z = board.position.z + 110;
            }


//            object.position.x = board.position.x + (i * 60);
//            object.position.y = board.position.y + (i * 40);
//            object.position.z = board.position.z + 100;


            object.rotation = board.rotation;

        }

    };

    var preppedStim = convertExperimentToThing(importJSON);
    console.log(preppedStim);

    // createStimTable is a WIP. Currently breaks the GUI
    //    createStimTable(preppedStim);
    makeStims(preppedStim);
</script>
</body>
</html>
